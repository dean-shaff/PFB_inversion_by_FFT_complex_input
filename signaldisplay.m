function signaldisplay()
%
% Takes as input a data file generated by "signalgen.m" and displays it
% in both the time and frequency domains.
% The input signal is not de-dispersed, so test using zero dispersion in
% the signal generator.
%
% Ignores the header section.
% -------
% Changes:
% --------
%
% Author           Date         Comments
% ---------------  -----------  ----------------------------------------
% I. Morrison      16-May-2015  Original version
% 
% ----------------------------------------------------------------------
 
close all; clear all; clc;

% Input file name
fname = 'fine_channel_8.dump';

hdrsize = 4096; %Header size
hdrtype = 'uint8'; % Data type for header ('uint8' = byte)
Nin = 2^11; %2^26; % Number of elements per initial FFT
ntype = 'single'; % Data type for each element in a pair ('single' = float)
nbytes = 4; % Number of bytes per data point for ntype
npol = 1; % Number of polarisations (should always be 2 when calc Stokes)
nbins = 2^10; % Number of bins within a pulse period
nfreq = 1; %2^7; % Number of frequency channels into which spectrum is divided
nseries = 1; % Number of time series to read and fft.

foffset = 1; % Number of time series offset into the input file before displaying
 
%dformat = 'realtocomplex'; %specifies conversion OF real or complex data
dformat = 'complextocomplex'; %specifies conversion OF real or complex data
 
% Instrument settings
%Tin = 64*0.0078125*1.E-6; % (seconds) sampling period for input data
f0 = 1405.; %MHz 
%df = -1.; %MHz  
f_sample_in = 0.8; %-11.4286; % Sampling frequency of input (MHz)

Nbits = 32;


 
       
 
%=============
% Set up parameters depending on whether incoming data is real or complex
switch dformat
    case 'realtocomplex' 
        Nmul = 2; % Multiplying factor in converting from real to complex
        NperNin = 1; % 1 data point per polariz per incoming time step
    case 'complextocomplex'
        Nmul = 1;
        NperNin = 2; % 1 real + 1 imag point per pol per incoming time step 
    otherwise
        warning('Conversion should be realtocomplex or complextocomplex.');
end
 
Tin  = 1/abs(f_sample_in)*1E-6; % Sample spacing of input (seconds)
df   = f_sample_in/Nmul; % Bandwidth/Nyquist frequency (MHz)
Tout = Tin*nfreq*Nmul; % Time spacing between output data elements
Nout = Nin/nfreq/Nmul; % Number of data elements in output time series
Pmul = Nmul; % Power multiplication factor for all but the DC channel

t0 = 0.0;
 
fid = fopen(fname);
 
% Read header
%fread(fid, hdrsize, hdrtype);
%disp(transpose(native2unicode(hdr))); % Show header
 
% Shift starting point for reading file (useful for debugging)
%pt = round(tau/Tin)*npol*nbytes*NperNin;
%fseek(fid, pt, 'cof');
 
% Array to store analytic sig
Vc   = complex(zeros(Nout, nfreq, npol, 'single'));
 
% Vector of times relative to first element
%trel = (0:nclip-1)*Tout; 
trel = (0:Nout-1)*Tout; % no clipping needed for DM = 0
n_lo = 0;
n_hi = 0;

tt = t0 + trel;
        
% Read stream of voltages into a single column
for ii = 1 : foffset
    Vstream = single(fread(fid, npol*Nin*NperNin, ntype));
end;

%====================
% Parse real and imag components if incoming data is complex
    
switch dformat
    case 'complextocomplex'
        Vstream = reshape(Vstream, 2, []);
        Vstream = complex(Vstream(1,:), Vstream(2,:));
end;
    
% Separate data into different polarisations: Vdat(1,:) and Vdat(2,:)
Vdat = reshape(Vstream, npol, []);


figure;
subplot(221); plot((1:Nout),real(Vdat(1,1:Nout))); box on; grid on; title('v1 Real'); 
subplot(223); plot((1:Nout),imag(Vdat(1,1:Nout))); box on; grid on; title('v1 Imag'); xlabel('time');
% subplot(222); plot((1:Nout),real(Vdat(2,1:Nout))); box on; grid on; title('v2 Real'); 
% subplot(224); plot((1:Nout),imag(Vdat(2,1:Nout))); box on; grid on; title('v2 Imag'); xlabel('time');


    
%==================== 
% Form analytic signal by taking the first half and multiplying by Pmul
    switch dformat
        case 'realtocomplex'
            F1all = fft(Vdat(1,:), Nin);
            F2all = fft(Vdat(2,:), Nin);
            F1 = [complex(F1all(1), F1all(Nout*nfreq+1)), ...
                F1all(2:Nout*nfreq)*Pmul];
            F2 = [complex(F2all(1), F2all(Nout*nfreq+1)), ...
                F2all(2:Nout*nfreq)*Pmul];
        case 'complextocomplex'
            F1 = fft(Vdat(1,:), Nin);
%            F2 = fft(Vdat(2,:), Nin);
    end;
    
    
    %=====================
    % Create filterbank 
    F1 = reshape(F1, Nout, nfreq);
%    F2 = reshape(F2, Nout, nfreq);
    
    %=====================
    % Don't scalar multiply by dispersion matrix since assume DM = 0, and then inverse FFT
    %Vc(:,:,1) = ifft(F1.*H, Nout);
    %Vc(:,:,2) = ifft(F2.*H, Nout);
    Vc(:,:,1) = ifft(F1, Nout);
%    Vc(:,:,2) = ifft(F2, Nout);
    
    %=====================
    % Remove ends of array that are corrupted by dispersion
    z1 = Vc((1+n_hi):(Nout - n_lo), :, 1);
%    z2 = Vc((1+n_hi):(Nout - n_lo), :, 2);
    
    %=====================

figure;
subplot(221); plot((1:Nout),real(z1(1:Nout))); box on; grid on; title('z1 Real'); 
subplot(223); plot((1:Nout),imag(z1(1:Nout))); box on; grid on; title('z1 Imag'); xlabel('time');
% subplot(222); plot((1:Nout),real(z2(1:Nout))); box on; grid on; title('z2 Real'); 
% subplot(224); plot((1:Nout),imag(z2(1:Nout))); box on; grid on; title('z2 Imag'); xlabel('time');


Z1 = fftshift(fft(z1));
%Z2 = fftshift(fft(z2));
 
figure;
subplot(221); plot((1:Nout),abs(Z1)); box on; grid on; title('Z1 Mag'); 
subplot(223); plot((1:Nout),angle(Z1)); box on; grid on; title('Z1 Phase'); xlabel('time');
% subplot(222); plot((1:Nout),abs(Z2)); box on; grid on; title('Z2 Mag'); 
% subplot(224); plot((1:Nout),angle(Z2)); box on; grid on; title('Z2 Phase'); xlabel('time');


fclose(fid);


return
end
